"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const vite_plugin_utils_1 = require("vite-plugin-utils");
const utils_1 = require("./utils");
const alias_1 = require("./alias");
const dynamic_import_vars_1 = require("./dynamic-import-vars");
const dynamic_import_helper_1 = require("./dynamic-import-helper");
const PLUGIN_NAME = 'vite-plugin-dynamic-import';
function dynamicImport(options = {}) {
    let config;
    let aliasContext;
    let dynamicImport;
    const dyImpt = {
        name: PLUGIN_NAME,
        configResolved(_config) {
            config = _config;
            aliasContext = new alias_1.AliasContext(_config);
            dynamicImport = new dynamic_import_vars_1.DynamicImportVars(aliasContext);
        },
        async transform(code, id, opts) {
            var _a, _b;
            const pureId = (0, vite_plugin_utils_1.cleanUrl)(id);
            const extensions = vite_plugin_utils_1.JS_EXTENSIONS.concat(vite_plugin_utils_1.KNOWN_SFC_EXTENSIONS);
            const globExtensions = ((_a = config.resolve) === null || _a === void 0 ? void 0 : _a.extensions) || extensions;
            const { ext } = path_1.default.parse(pureId);
            if (/node_modules/.test(pureId))
                return;
            if (!extensions.includes(ext))
                return;
            if (!(0, utils_1.hasDynamicImport)(code))
                return;
            if (await ((_b = options.filter) === null || _b === void 0 ? void 0 : _b.call(options, code, id, opts)) === false)
                return;
            const ast = this.parse(code);
            let dynamicImportIndex = 0;
            const dynamicImportRecords = [];
            await (0, utils_1.simpleWalk)(ast, {
                async ImportExpression(node) {
                    const importeeRaw = code.slice(node.source.start, node.source.end);
                    // check @vite-ignore which suppresses dynamic import warning
                    if (utils_1.viteIgnoreRegex.test(importeeRaw))
                        return;
                    const matched = importeeRaw.match(utils_1.importeeRawRegex);
                    // currently, only importee in string format is supported
                    if (!matched)
                        return;
                    const [, startQuotation, importee, endQuotation] = matched;
                    // this is a normal path
                    if (utils_1.normallyImporteeRegex.test(importee))
                        return;
                    const replaced = await aliasContext.replaceImportee(importee, id);
                    // this is a normal path
                    if (replaced && utils_1.normallyImporteeRegex.test(replaced.replacedImportee))
                        return;
                    const globResult = await globFiles(dynamicImport, node, code, pureId, globExtensions, options.depth !== false);
                    if (!globResult)
                        return;
                    const dyRecord = {
                        node: {
                            type: node.type,
                            start: node.start,
                            end: node.end,
                        },
                        importeeRaw,
                    };
                    if (globResult['normally']) {
                        // this is a normal path
                        const { normally } = globResult;
                        dynamicImportRecords.push({ ...dyRecord, normally });
                    }
                    else {
                        const { glob, files, alias } = globResult;
                        if (!files.length)
                            return;
                        const importeeMappings = listImporteeMappings(glob, globExtensions, files, alias);
                        const importRuntime = (0, dynamic_import_helper_1.generateDynamicImportRuntime)(importeeMappings, dynamicImportIndex++);
                        dynamicImportRecords.push({ ...dyRecord, importRuntime });
                    }
                },
            });
            let dyImptRutimeBody = '';
            if (dynamicImportRecords.length) {
                for (let len = dynamicImportRecords.length, i = len - 1; i >= 0; i--) {
                    const { node, importeeRaw, importRuntime, normally, } = dynamicImportRecords[i];
                    let placeholder;
                    if (normally) {
                        placeholder = `import("${normally.glob}")`;
                    }
                    else {
                        /**
                         * this is equivalent to a non rigorous model
                         *
                         // extension should be removed, because if the "index" file is in the directory, an error will occur
                         //
                         // e.g.
                         // â”œâ”€â”¬ views
                         // â”‚ â”œâ”€â”¬ foo
                         // â”‚ â”‚ â””â”€â”€ index.js
                         // â”‚ â””â”€â”€ bar.js
                         //
                         // when we use `./views/*.js`, we want it to match `./views/foo/index.js`, `./views/bar.js`
                         *
                         // const starts = importeeRaw.slice(0, -1)
                         // const ends = importeeRaw.slice(-1)
                         // const withOutExtImporteeRaw = starts.replace(path.extname(starts), '') + ends
                         // placeholder = `${importRuntime.name}(${withOutExtImporteeRaw})`
                         */
                        placeholder = `${importRuntime.name}(${importeeRaw})`;
                        dyImptRutimeBody = importRuntime.body + dyImptRutimeBody;
                    }
                    code = code.slice(0, node.start) + placeholder + code.slice(node.end);
                }
                if (dyImptRutimeBody) {
                    code += '\n// --------- ${PLUGIN_NAME} ---------\n' + dyImptRutimeBody;
                }
                return {
                    code,
                    // TODO: sourcemap
                    map: { mappings: '' },
                };
            }
        },
    };
    return (0, vite_plugin_utils_1.sortPlugin)({
        plugin: dyImpt,
        names: Object.values(vite_plugin_utils_1.OfficialPlugins).flat(),
        enforce: 'post',
    });
}
exports.default = dynamicImport;
async function globFiles(dynamicImport, ImportExpressionNode, sourceString, pureId, extensions, depth) {
    const node = ImportExpressionNode;
    const code = sourceString;
    const { alias, glob: globObj } = await dynamicImport.dynamicImportToGlob(node.source, code.substring(node.start, node.end), pureId);
    if (!globObj.valid) {
        if (utils_1.normallyImporteeRegex.test(globObj.glob)) {
            return { normally: { glob: globObj.glob, alias } };
        }
        // this was not a variable dynamic import
        return null;
    }
    let { glob } = globObj;
    let globWithIndex;
    glob = (0, dynamic_import_vars_1.tryFixGlobSlash)(glob) || glob;
    depth && (glob = (0, dynamic_import_vars_1.toDepthGlob)(glob));
    const tmp = (0, dynamic_import_vars_1.tryFixGlobExtension)(glob, extensions);
    if (tmp) {
        glob = tmp.glob;
        globWithIndex = tmp.globWithIndex;
    }
    let files = fast_glob_1.default.sync(globWithIndex ? [glob, globWithIndex] : glob, { cwd: path_1.default.dirname(/* ðŸš§-â‘  */ pureId) });
    files = files.map(file => !file.startsWith('.') ? /* ðŸš§-â‘¢ */ './' + file : file);
    let aliasWithFiles;
    if (alias) {
        const static1 = alias.importee.slice(0, alias.importee.indexOf('*'));
        const static2 = alias.replacedImportee.slice(0, alias.replacedImportee.indexOf('*'));
        aliasWithFiles = {
            ...alias,
            files: files.map(file => 
            // Recovery alias `./views/*` -> `@/views/*`
            file.replace(static2, static1)),
        };
    }
    return {
        glob,
        alias: aliasWithFiles,
        files,
    };
}
function listImporteeMappings(glob, extensions, importeeList, alias) {
    const hasExtension = extensions.some(ext => glob.endsWith(ext));
    return importeeList.reduce((memo, importee, idx) => {
        const realFilepath = importee;
        importee = alias ? alias.files[idx] : importee;
        if (hasExtension) {
            return Object.assign(memo, { [realFilepath]: [importee] });
        }
        const ext = extensions.find(ext => importee.endsWith(ext));
        const list = [
            // foo/index
            importee.replace(ext, ''),
            // foo/index.js
            importee,
        ];
        if (importee.endsWith('index' + ext)) {
            // foo
            list.unshift(importee.replace('/index' + ext, ''));
        }
        return Object.assign(memo, { [realFilepath]: list });
    }, {});
}
